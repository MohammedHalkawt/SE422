Takeaway from last lecture: when we are making a multithread system, threads most of the time wont be independent from eachother. There needs to be an algorithm that will make them work in a sequential way. because some parts need to be delayed in order for some steps from other parts to be fullfiled.

After having a few threads you would want to organize how they work together by the sequence they are called.

if we have t1 t2 and t3, and we know that for the application to work, we need a block of code to be run at t1 so that t3 would do a part of its work correctly, so we need to guarantee that t1 must be called before t3. 
or lets say we have t1 and t2, and in order for a block of code in t3 to be run perfectly, we know that we need to run t1 first and then t2.
one scenario that would be the hardest is not to specify the order of the first two, saying t3 should execute once the blocks of code in t1 and t2 are executed, no matter in what order for t1 and t2. here we try to manage causality across different threads. and here t1 and t2 need to happen before the block of code we specified in t3.

join is one tool to specify happens-before in threads, because for example it says a block of code in t3 should happen once t1 finishes its tasks in the place specified. the issue is that it only works under the condition that the thread must die and stop in join, which is not very good since everything needs to stop and not in the middle of the thread.
we want a way that we can go until the middle of t1 and after that t3 can start, it was what we learned from last lecture, which was a signaling mechanism: we would have a shared object between both threads, for example o1, then we would put t3 from the specified code block to sleep by calling o1.wait(), and in t1 we can say o1.notify() when we want t3 to run after the specified block of code in t1 has finished.

before sending the signal, the object is locked by t1, when we send the notify signall to t3, t3 also recieves the lock sent from t1, if t1 doesnt require the lock again, both t1 and t3 can run in parallel, if t1 does need the lock again, it would be put on wait and would wait for a notify signal from t3.

A scenario where notify and notifyall may not work really well: if we have three threads, t1 t2 and t3, and we have three blocks of code across these three threads, the condition is that the block in t3 needs to run after t1 and t2's blocks of code, with no condition of the order of t1 and t2, so they can run in parallel, we just need to guarantee that t3's block happens after them. we will first try to do it with wait and notify: we will first have an object (o1) shared between the three threads, in both t1 and t2 we would call notify after their blocks of code, and in t3 before its block we will call wait so it can wait for them, this will not work because if t3 gets even 1 notify signal it will instantly run, which is wrong. we would then say we will call wait() twice so that it would need to wait 2 times. but lets say the o1.notifies in both t1 and t2 are in loops, meaning calling wait 2 times would not be correct since t1 can send notify 2 times because of the loop. we will then say we will have 2 shared objects, o1 and o2, in t1's side we would use o1, and in t2's side we would use o2, and in t3 we would call wait twice once in o1.wait() and once in o2.wait(), in theory this works but in practicallity there are edge cases and this would not be very good. for example: if t2 is fast and t1 is slow, then t3 would miss t2's signal since it called o1.wait() first, now the signal was missed, and even if t1 sends its signal later, t3 would sleep forever since it missed t2's signal.

these tools that synchronize betwene threads are called thread synchronizers. 
we will use a tool for this specific scenario (where we try to define happens before betwene multiple threads where we have to wait for signal from more than one thread), its called a CountDownLatch, now we will do the code.